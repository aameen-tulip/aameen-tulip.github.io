<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-10-20 Thu 11:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Nix for C.H.U.D.s</title>
<meta name="author" content="Alex Ameen" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>

<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<meta content='width=device-width, initial-scale=1, maximum-scale=1,
               user-scalable=no'
      name='viewport'>
<style>html {
  touch-action: manipulation;
  -webkit-text-size-adjust: 100%;
}
body {
  padding: 0;
  margin: 0;
  background: #f2f6fa;
  color: #3c495a;
  font-weight: normal;
  font-size: 15px;
  font-family: "San Francisco", "Roboto", "Arial", sans-serif;
}
h2,
h3,
h4,
h5,
h6 {
  font-family: "Trebuchet MS", Verdana, sans-serif;
  color: #586b82;
  padding: 0;
  margin: 20px 0 10px 0;
  font-size: 1.1em;
}
h2 {
  margin: 30px 0 10px 0;
  font-size: 1.2em;
}
a {
  color: #3fa7ba;
  text-decoration: none;
}
p {
  margin: 6px 0;
  text-align: justify;
}
ul,
ol {
  margin: 0;
  text-align: justify;
}
ul > li > code {
  color: #586b82;
}
pre {
  white-space: pre-wrap;
}
#content {
  width: 96%;
  max-width: 1000px;
  margin: 2% auto 6% auto;
  background: white;
  border-radius: 2px;
  border-right: 1px solid #e2e9f0;
  border-bottom: 2px solid #e2e9f0;
  padding: 0 115px 150px 115px;
  box-sizing: border-box;
}
#postamble {
  display: none;
}
h1.title {
  background-color: #343c44;
  color: #fff;
  margin: 0 -115px;
  padding: 60px 0;
  font-weight: normal;
  font-size: 2em;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}
@media (max-width: 1050px) {
  #content {
    padding: 0 70px 100px 70px;
  }
  h1.title {
    margin: 0 -70px;
  }
}
@media (max-width: 800px) {
  #content {
    width: 100%;
    margin-top: 0;
    margin-bottom: 0;
    padding: 0 4% 60px 4%;
  }
  h1.title {
    margin: 0 -5%;
    padding: 40px 5%;
  }
}
pre,
.verse {
  box-shadow: none;
  // background-color: #f9fbfd;
  background-color: #f9fbfd;
  border: 1px solid #e2e9f0;
  color: #586b82;
  padding: 10px;
  font-family: monospace;
  overflow: auto;
  margin: 6px 0;
}
#table-of-contents {
  margin-bottom: 50px;
  margin-top: 50px;
}
#table-of-contents h2 {
  margin-bottom: 5px;
}
#text-table-of-contents ul {
  padding-left: 15px;
}
#text-table-of-contents > ul {
  padding-left: 0;
}
#text-table-of-contents li {
  list-style-type: none;
}
#text-table-of-contents a {
  color: #7c8ca1;
  font-size: 0.95em;
  text-decoration: none;
}
table {
  border-color: #586b82;
  font-size: 0.95em;
}
table thead {
  color: #586b82;
}
table tbody tr:nth-child(even) {
  background: #f9f9f9;
}
table tbody tr:hover {
  background: #586b82 !important;
  color: white;
}
table .left {
  text-align: left;
}
table .right {
  text-align: right;
}
.todo {
  font-family: inherit;
  color: inherit;
}
.done {
  color: inherit;
}
.tag {
  background: initial;
}
.tag > span {
  background-color: #eee;
  font-family: monospace;
  padding-left: 7px;
  padding-right: 7px;
  border-radius: 2px;
  float: right;
  margin-left: 5px;
}
#text-table-of-contents .tag > span {
  float: none;
  margin-left: 0;
}
.timestamp {
  color: #7c8ca1;
}
@media print {
  @page {
    margin-bottom: 3cm;
    margin-top: 3cm;
    margin-left: 2cm;
    margin-right: 2cm;
    font-size: 10px;
  }
  #content {
    border: none;
  }
}
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Nix for C.H.U.D.s</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org327c7c9">1. Resources</a>
<ul>
<li><a href="#org16ff0f2">1.1. Expressions Manual</a></li>
</ul>
</li>
<li><a href="#org4d933da">2. Nix Language</a>
<ul>
<li><a href="#orga7781eb">2.1. Value Types</a>
<ul>
<li><a href="#org7459e33">2.1.1. Primitives</a></li>
<li><a href="#orgc158750">2.1.2. Lists</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org1c5b627">3. Nix CLI</a></li>
<li><a href="#org0de5777">4. Source Filtering</a>
<ul>
<li><a href="#org9cbc720">4.1. Source Filters Overview</a></li>
<li><a href="#org37464f3">4.2. Basic Filtering Examples</a>
<ul>
<li><a href="#orge964cdd">4.2.1. Filtering a local project directory</a></li>
<li><a href="#orgb505e00">4.2.2. Nesting Filters</a></li>
<li><a href="#org84c3866">4.2.3. Ignore Nix files ( Composed )</a></li>
<li><a href="#orgb60a3b5">4.2.4. Composing filters</a></li>
</ul>
</li>
<li><a href="#org1285d22">4.3. Writing filters</a>
<ul>
<li><a href="#org618f579">4.3.1. A more useful filter: Optimized <code>node2nix</code> ignores.</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org8557f4c">5. Bread and Butter Functions</a>
<ul>
<li><a href="#orgfc54a45">5.1. <code>listToAttrs</code>, <code>attrNames</code>, and <code>attrValues</code></a>
<ul>
<li><a href="#orgf891550">5.1.1. The Basics</a></li>
<li><a href="#org508073d">5.1.2. Some Simple Utilities</a></li>
</ul>
</li>
<li><a href="#org9b83774">5.2. <code>fromJSON</code>, <code>toJSON</code>, <code>readFile</code>, <code>toFile</code>, and <code>fetchurl</code></a>
<ul>
<li><a href="#org05b6407">5.2.1. The Basics</a></li>
<li><a href="#org652ade8">5.2.2. Some Simple Utilities</a></li>
<li><a href="#orgde6460b">5.2.3. Related Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org327c7c9" class="outline-2">
<h2 id="org327c7c9"><span class="section-number-2">1.</span> Resources</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org16ff0f2" class="outline-3">
<h3 id="org16ff0f2"><span class="section-number-3">1.1.</span> Expressions Manual</h3>
<div class="outline-text-3" id="text-1-1">
<p>
<a href="https://nixos.org/manual/nix/stable/expressions/language-values.html">https://nixos.org/manual/nix/stable/expressions/language-values.html</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org4d933da" class="outline-2">
<h2 id="org4d933da"><span class="section-number-2">2.</span> Nix Language</h2>
<div class="outline-text-2" id="text-2">
<p>
Use <code>nix repl</code> to try various snippets.
</p>
</div>

<div id="outline-container-orga7781eb" class="outline-3">
<h3 id="orga7781eb"><span class="section-number-3">2.1.</span> Value Types</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-org7459e33" class="outline-4">
<h4 id="org7459e33"><span class="section-number-4">2.1.1.</span> Primitives</h4>
<div class="outline-text-4" id="text-2-1-1">
<ul class="org-ul">
<li>Null: <code>null</code></li>
<li>Booleans: <code>true</code>, <code>false</code></li>
<li>Integers: <code>1</code>, <code>-1</code>, <code>0</code></li>
<li>Path: <code>./foo/bar</code>, <code>./.</code>, <code>/etc/nix/nix.conf</code>, <code>../../baz.txt</code></li>
<li>Strings: <code>"foo"</code>, <code>''bar "baz" quux''</code></li>
</ul>
</div>
</div>
<div id="outline-container-orgc158750" class="outline-4">
<h4 id="orgc158750"><span class="section-number-4">2.1.2.</span> Lists</h4>
<div class="outline-text-4" id="text-2-1-2">
<div class="org-src-container">
<pre class="src src-nix">
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org1c5b627" class="outline-2">
<h2 id="org1c5b627"><span class="section-number-2">3.</span> Nix CLI</h2>
<div class="outline-text-2" id="text-3">
<p>
The Nix CLI tools are transitioning from a legacy set of tools towards a unified CLI ( referred to as experimental ).
With that in mind, it&rsquo;s useful to know which legacy/experimental commands are equivalent, and which are &ldquo;mostly equivalent&rdquo;.
</p>

<p>
The largest difference between legacy and experimental commands is that legacy CLI operates on files like <code>default.nix</code>, <code>shell.nix</code>, <code>release.nix</code>, and <code>overlay(s).nix</code>, while experimental commands operate on <code>flake.nix</code> files ( essentially a unified form of the legacy files ).
In the table below I will generally gloss over &ldquo;which files&rdquo; a command targets and instead focus on more substantial content.
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Task</th>
<th scope="col" class="org-left">Legacy</th>
<th scope="col" class="org-left">Experimental</th>
<th scope="col" class="org-left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Build default derivation in CWD</td>
<td class="org-left">nix-build</td>
<td class="org-left">nix build</td>
<td class="org-left">Legacy assumes <code>default.nix</code> is a single derivation, not a package set.</td>
</tr>

<tr>
<td class="org-left">Build a derivation from a package set</td>
<td class="org-left">nix-build &rsquo;&lt;pkgset&gt;&rsquo; -A foo</td>
<td class="org-left">nix build pkgset#foo</td>
<td class="org-left">Legacy searches <code>default.nix</code> in CWD is <code>pkgset</code> is not specified.</td>
</tr>

<tr>
<td class="org-left">Enter devShell for default package in CWD</td>
<td class="org-left">nix-shell</td>
<td class="org-left">nix develop</td>
<td class="org-left">If a shell is not explicitly defined, one is generated from the default package&rsquo;s recipe.</td>
</tr>

<tr>
<td class="org-left">Enter devShell from a package set</td>
<td class="org-left">nix-shell &rsquo;&lt;pkgset&gt;&rsquo; -A foo</td>
<td class="org-left">nix develop pkgset#foo</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Search for a package</td>
<td class="org-left">nix-env -qa &rsquo;PATTERN&rsquo;</td>
<td class="org-left">nix search nixpkgs &rsquo;PATTERN&rsquo;</td>
<td class="org-left">PATTERN is used to match any string in a package name or description. Commonly &rsquo;\.NAME&rsquo; is used to find a package by name.</td>
</tr>

<tr>
<td class="org-left">Install a package globally</td>
<td class="org-left">nix-env -f &rsquo;&lt;pkgset&gt;&rsquo; -iA foo</td>
<td class="org-left">nix profile install pkgset#foo</td>
<td class="org-left">Global package installation is discouraged. Legacy and experimental user profiles may not be used together.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org0de5777" class="outline-2">
<h2 id="org0de5777"><span class="section-number-2">4.</span> Source Filtering</h2>
<div class="outline-text-2" id="text-4">
<p>
Many Nix expresssions, particularly those which produce &ldquo;derivations&rdquo;
( build recipes ) carry an attribute named <code>src</code> which is used to create your
build area.
</p>

<p>
In most cases <code>src</code>, and all of its contents, effect the hash of your derivation
such that any file modifications in that tree will trigger a cache miss ( rebuild ).
</p>

<p>
With that in mind, filtering a source tree down to the minimal list of files that
really effect a build&rsquo;s outputs can make a night and day difference in caching
performance; this is especially true in large source trees such as a mono-repo.
</p>

<p>
Nix carries a simple builtin command <code>builtins.filterSource</code> which allows us to
perform rudimentary filtering, and Nixpkgs carries a collection of more robust
filters which you will want to become familiar with.
</p>
</div>

<div id="outline-container-org9cbc720" class="outline-3">
<h3 id="org9cbc720"><span class="section-number-3">4.1.</span> Source Filters Overview</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li><code>builtins.filterSource</code> : simple builtin filter routine.
<ul class="org-ul">
<li>Nice for removing a few files from a shallow source tree.</li>
<li>Unlike Nixpkgs&rsquo; <code>lib.cleanSource</code>, the builtin function cannot be
composed with other filters, and cannot be used with the debug tracing
function <code>lib.sources.trace</code>.</li>
<li>Significantly faster than the Nixpkgs filters; &ldquo;closer to the metal&rdquo;.
It is implemented in C++ and takes advantage of platform specific
filesystem operations directly.</li>
</ul></li>

<li><code>lib.cleanSource</code> : sane default filter which removes temporary and VC files.
<ul class="org-ul">
<li>This is your bread and butter filter to apply to a Git project&rsquo;s top level.</li>
<li>Deletes the <code>.git/</code> directory which is essential for working with locally
cloned repositories.</li>
<li>Deletes common temporary files such as <code>*~</code> and <code>.*.sw*</code> produced by many
editors, build artifacts such as <code>*.o</code> and <code>*.so</code>, any <code>result</code> symlinks
produced by Nix, and oddball filesystem nodes like sockets.</li>
<li>May be composed with other filters, commonly acting as the base filter to
be applied first.</li>
</ul></li>

<li><code>lib.cleanSourceWith</code> : applies custom filters and composes them.
<ul class="org-ul">
<li>Used to run any user defined filter, and build sequences of filters.</li>
<li>Uses the exact same set of arguments seen in <code>builtins.filterSource</code>, and
is actually the ancestor of the builtin.</li>
<li>Composing filters with <code>lib.cleanSourceWith</code> is significantly more efficient
the filtering a tree, and passing to another filter.
Composition merges filter predicates and applies them to a source tree
once without making multiple copies of the source tree between filters.</li>
<li>Composed filters are applied sequentially as:
<code>f1: f2: ( path: type: ( f1 path type ) &amp;&amp; ( f2 path type ) )</code></li>
</ul></li>

<li><code>lib.sources.trace</code> : traces source filters for debugging.
<ul class="org-ul">
<li>Generally used in a REPL when writing a filter.</li>
<li>Do not check in derivations that use <code>trace</code>, it&rsquo;s a debugging function
intended for interactive use.</li>
<li>Used as <code>lib.sources.trace ( lib.cleanSource ./. )</code></li>
<li>I use this literally every time I&rsquo;m writing a filter, I strongly suggest
taking advantage of it.</li>
</ul></li>

<li><code>lib.sources.sourceByRegex</code> : produces a filter from regex expressions.
<ul class="org-ul">
<li>Given a list of patterns, returns true if a file/directory matches any.</li>
<li>Great for recursively pulling files by name like <code>.*/package\.json$</code>.</li>
<li>Uses PCRE regex, not POSIX globbing.</li>
<li>Internally this uses <code>cleanSourceWith</code>, so it may be composed with other
<code>lib.sources.*</code> cleaners.</li>
<li>WARNING: that since Nix 2.4 Darwin and Linux platforms will produce
different results when attempting &ldquo;non-greedy&rdquo; PCRE matches such as
<code>[^a]*?</code> or <code>[^a]{0,}</code>.
This platform dependant behavior is a result of LLVM developers failing
to implement PCRE as specified.
This issue is not limited to Nix, it applies to any software which uses
LLVM&rsquo;s implementation of PCRE - keep your eyes peeled for this elsewhere.</li>
</ul></li>

<li><code>lib.sources.sourceFilesBySuffices</code> : produces a filter from a list of suffices.
<ul class="org-ul">
<li>Suffices are interpreted literally - don&rsquo;t use regex.</li>
<li>Almost always used to match file extensions.</li>
<li>This largely exists to account for the LLVM debacle mentioned above.</li>
<li>Internally this uses <code>cleanSourceWith</code>, so it may be composed with other
<code>lib.sources.*</code> cleaners.</li>
</ul></li>

<li><code>nix-gitignore.gitignoreSource[Pure]</code> : filters using <code>.gitignore</code> syntax.
<ul class="org-ul">
<li>Accepts a list of patterns which are applied following <code>.gitignore</code> style
filtering rules.</li>
<li><code>gitignoreSource</code> supplements the provided patterns with any <code>.gitignore</code>
files found in the source tree.
Reading <code>.gitignore</code> files incurs a considerable performance cost.
WARNING: if <code>src</code> is not the git repository root, this function will not
be able to read <code>.gitignore</code> files in parent directories.
With this in mind I do not suggest using this function in a large mono-repo.</li>
<li><code>gitignoreSourcePure</code> ignores any <code>.gitignore</code> files, and is
purely declarative.
This has significantly improved performance and caching, I strongly
recommend using this function over the impure form in large repositories.</li>
<li>In practice I&rsquo;ve found that <code>lib.sources.sourceByRegex</code> is often much
easier to reason about; gitignore syntax has wonky rules.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org37464f3" class="outline-3">
<h3 id="org37464f3"><span class="section-number-3">4.2.</span> Basic Filtering Examples</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-orge964cdd" class="outline-4">
<h4 id="orge964cdd"><span class="section-number-4">4.2.1.</span> Filtering a local project directory</h4>
<div class="outline-text-4" id="text-4-2-1">
<div class="org-src-container">
<pre class="src src-nix">{ pkgs   ? <span style="color: #c678dd;">import</span> <span style="color: #a9a1e1;">&lt;nixpkgs&gt;</span> {}
, stdenv ? pkgs.stdenv
, lib    ? pkgs.lib
}:
stdenv.mkDerivation {
  <span style="color: #dcaeea;">pname</span> = <span style="color: #98be65;">"my-project"</span>;
  <span style="color: #dcaeea;">version</span> = <span style="color: #98be65;">"0.0.1"</span>;
  <span style="color: #dcaeea;">src</span> = lib.cleanSource <span style="color: #a9a1e1;">./.</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb505e00" class="outline-4">
<h4 id="orgb505e00"><span class="section-number-4">4.2.2.</span> Nesting Filters</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
Discouraged, but fine for small codebases.
</p>

<div class="org-src-container">
<pre class="src src-nix">{ pkgs          ? <span style="color: #c678dd;">import</span> <span style="color: #a9a1e1;">&lt;nixpkgs&gt;</span> {}
, stdenv        ? pkgs.stdenv
, lib           ? pkgs.lib
, nix-gitignore ? pkgs.nix-gitignore
}:
stdenv.mkDerivation {
  <span style="color: #dcaeea;">pname</span> = <span style="color: #98be65;">"my-project"</span>;
  <span style="color: #dcaeea;">version</span> = <span style="color: #98be65;">"0.0.1"</span>;
  <span style="color: #5B6268;"># A bit more efficient than `lib.sources.sourceByRegex' because</span>
  <span style="color: #5B6268;"># these directories are pruned immediately, and aren't traversed.</span>
  <span style="color: #dcaeea;">src</span> = nix-gitignore.gitignoreFilterPure [
    <span style="color: #98be65;">"node_modules/"</span>
    <span style="color: #98be65;">".yarn/cache/"</span>
  ] ( lib.cleanSource <span style="color: #a9a1e1;">./.</span> );
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org84c3866" class="outline-4">
<h4 id="org84c3866"><span class="section-number-4">4.2.3.</span> Ignore Nix files ( Composed )</h4>
<div class="outline-text-4" id="text-4-2-3">
<div class="org-src-container">
<pre class="src src-nix">{ pkgs          ? <span style="color: #c678dd;">import</span> <span style="color: #a9a1e1;">&lt;nixpkgs&gt;</span> {}
, stdenv        ? pkgs.stdenv
, lib           ? pkgs.lib
}:
stdenv.mkDerivation {
  <span style="color: #dcaeea;">pname</span> = <span style="color: #98be65;">"my-project"</span>;
  <span style="color: #dcaeea;">version</span> = <span style="color: #98be65;">"0.0.1"</span>;
  <span style="color: #5B6268;"># `sourceFilesBySuffices' uses, `cleanSourceWith' internally, so these will</span>
  <span style="color: #5B6268;"># compose properly.</span>
  <span style="color: #dcaeea;">src</span> = lib.sources.sourceFilesBySuffices [<span style="color: #98be65;">".nix"</span>] ( lib.cleanSource <span style="color: #a9a1e1;">./.</span> );
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb60a3b5" class="outline-4">
<h4 id="orgb60a3b5"><span class="section-number-4">4.2.4.</span> Composing filters</h4>
<div class="outline-text-4" id="text-4-2-4">
<div class="org-src-container">
<pre class="src src-nix">{ pkgs          ? <span style="color: #c678dd;">import</span> <span style="color: #a9a1e1;">&lt;nixpkgs&gt;</span> {}
, stdenv        ? pkgs.stdenv
, lib           ? pkgs.lib
}:
<span style="color: #51afef;">let</span>
  <span style="color: #51afef;">inherit</span> (lib) cleanSource cleanSourceWith;
  <span style="color: #5B6268;"># Remove `*/.yarn/cache' directories.</span>
  <span style="color: #dcaeea;">cleanYarnCacheFilter</span> = name: type:
    ! ( ( type == <span style="color: #98be65;">"directory"</span> )                       &amp;&amp;
        ( ( <span style="color: #c678dd;">baseNameOf</span> name ) == <span style="color: #98be65;">"cache"</span> )            &amp;&amp;
        ( ( <span style="color: #c678dd;">baseNameOf</span> ( <span style="color: #c678dd;">dirOf</span> name ) ) == <span style="color: #98be65;">".yarn"</span> ) <span style="color: #5B6268;"># `dirOf' is like `dirname'</span>
      );

  <span style="color: #5B6268;"># Remove `*/node_modules' directories</span>
  <span style="color: #dcaeea;">cleanNodeModulesFilter</span> = name: type:
    ! ( ( type == <span style="color: #98be65;">"directory"</span> ) &amp;&amp; ( ( <span style="color: #c678dd;">baseNameOf</span> name ) == <span style="color: #98be65;">"node_modules"</span> ) );

  <span style="color: #5B6268;"># Clean cached Node.js artifacts, and apply Nix's default clean routine.</span>
  <span style="color: #dcaeea;">cleanNodeSource</span> = src:
    cleanSourceWith {
      <span style="color: #dcaeea;">filter</span> = cleanYarnCacheFilter;
      <span style="color: #dcaeea;">src</span> = cleanSourceWith {
        <span style="color: #dcaeea;">filter</span> = cleanNodeModulesFilter;
        <span style="color: #dcaeea;">src</span> = cleanSource src;
      };
    };
<span style="color: #51afef;">in</span> stdenv.mkDerivation {
  <span style="color: #dcaeea;">pname</span> = <span style="color: #98be65;">"my-project"</span>;
  <span style="color: #dcaeea;">version</span> = <span style="color: #98be65;">"0.0.1"</span>;
  <span style="color: #dcaeea;">src</span> = cleanNodeSource <span style="color: #a9a1e1;">./.</span>;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1285d22" class="outline-3">
<h3 id="org1285d22"><span class="section-number-3">4.3.</span> Writing filters</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Both <code>builtins.filterSource</code> and <code>lib.sources.cleanSourceWith</code> accept functions with
the prototype <code>filter :: Name (Path/File Name) -&gt; Type (Filetype) -&gt; Boolean</code>
where <code>Type ::= "directory" | "regular" | "symlink" | "unknown"</code>, &ldquo;unknown&rdquo;
being Sockets and other oddball filesystem node types.
A filter function is expected to return <code>true</code> if a file should be preserved,
and <code>false</code> if a file should be removed.
</p>

<p>
An example filter which unconditionally preserves all files would be:
</p>
<div class="org-src-container">
<pre class="src src-nix"><span style="color: #51afef;">let</span> <span style="color: #dcaeea;">myFilter</span> = name: type: <span style="color: #c678dd;">true</span>;
<span style="color: #51afef;">in</span> builtins.filterSource myFilter <span style="color: #a9a1e1;">./.</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">Or equivalently ( since we never reference `name' or `type' ) :</span>
builtins.filterSource ( _: _: <span style="color: #c678dd;">true</span> ) <span style="color: #a9a1e1;">./.</span>
</pre>
</div>

<p>
The filter above could also be used with Nixpkgs <code>lib.cleanSourceWith</code>:
</p>
<div class="org-src-container">
<pre class="src src-nix">lib.cleanSourceWith { <span style="color: #dcaeea;">filter</span> = _: _: <span style="color: #c678dd;">true</span>; <span style="color: #dcaeea;">src</span> = <span style="color: #a9a1e1;">./.</span>; }
</pre>
</div>
</div>

<div id="outline-container-org618f579" class="outline-4">
<h4 id="org618f579"><span class="section-number-4">4.3.1.</span> A more useful filter: Optimized <code>node2nix</code> ignores.</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
A common Nix utility <code>node2nix</code> uses <code>nix-gitignore.gitignoreSourcePure</code>
to pluck just the <code>package.json</code> and <code>package-lock.json</code> files from a
source tree.
</p>

<p>
In this case, <code>nix-gitignore.gitignoreSourcePure</code> is somewhat unnecessary,
since the underlying predicate &ldquo;only keep these two files&rdquo; is dead simple.
Really, when we are building a single package, you should really use
<code>builtins.pathExists</code> with <code>srcs = [...]</code>; but because <code>node2nix</code> is
designed to possibly build groups of packages in a tree, it needs to
preserve <code>package[-lock].json</code> files recursively.
However, we can still improve the existing implementation by writing a
filter directly, which will save us from evaluating an unnecessarily
expensive routine.
</p>

<p>
In summary, our goal is simply: filter a source tree, preserving only
<code>package.json</code> and <code>package-lock.json</code> files.
</p>
</div>

<ol class="org-ol">
<li><a id="org6c082f0"></a>Rough Draft<br />
<div class="outline-text-5" id="text-4-3-1-1">
<p>
A naive implementation of this routine would resemble the example above for
&ldquo;Composing filters&rdquo;, but that routine would fail to preserve files
in subdirectories.
The example below illustrates the issue.
The expected output is:
  <code>[ "package-lock.json" "package.json" "foo/" ]</code>
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #ECBE7B;">mkdir</span> -p /tmp/naive-nix-filter/foo;
<span style="color: #ECBE7B;">cd</span> /tmp/naive-nix-filter &gt;/dev/null;
<span style="color: #ECBE7B;">touch</span> <span style="color: #51afef;">{</span>,foo/<span style="color: #51afef;">}</span>package<span style="color: #51afef;">{</span>,-lock<span style="color: #51afef;">}</span>.json;
<span style="color: #ECBE7B;">cat</span> &lt;&lt;<span style="color: #98be65;">'EOF'</span> &gt; naive.nix
<span style="color: #98be65;">let</span>
<span style="color: #98be65;">  inherit (builtins) attrValues mapAttrs readDir filterSource;</span>

<span style="color: #98be65;">  # A useful idiom for the REPL.</span>
<span style="color: #98be65;">  </span><span style="color: #98be65;">ls</span><span style="color: #98be65;"> = dir:</span>
<span style="color: #98be65;">    let f2str = n: t: if t == "directory" then n + "/" else n;</span>
<span style="color: #98be65;">    in attrValues ( mapAttrs f2str ( readDir dir ) );</span>

<span style="color: #98be65;">  naiveFilter = name: type: let bname = baseNameOf name; in</span>
<span style="color: #98be65;">    ( type == "regular" ) &amp;&amp;</span>
<span style="color: #98be65;">    ( ( bname == "package.json" ) || ( bname == "package-lock.json" ) );</span>

<span style="color: #98be65;">  src = filterSource naiveFilter ./.;</span>
<span style="color: #98be65;">in </span><span style="color: #98be65;">ls</span><span style="color: #98be65;"> src</span>
<span style="color: #98be65;">EOF</span>
nix eval -f ./naive.nix;
<span style="color: #ECBE7B;">cd</span> - &gt;/dev/null;
<span style="color: #ECBE7B;">rm</span> -rf /tmp/naive-nix-filter;
</pre>
</div>

<pre class="example">
[ "package-lock.json" "package.json" ]
</pre>


<p>
The behavior above illustrates the Nix processes filters using BFS, which makes
sense considering we don&rsquo;t want to traverse directories that are going to be pruned.
But in this case, we actually don&rsquo;t want to delete <code>foo/</code>, so lets try preserving
all directories this time, and for kicks we&rsquo;ll add a directory with a file that we
DO want to be deleted.
</p>
</div>
</li>

<li><a id="orga0c0107"></a>A Working Filter<br />
<div class="outline-text-5" id="text-4-3-1-2">
<p>
This round we will opt for <code>cleanSourceWith</code> this time so we can <code>trace</code> into subdirs;
while we could go down the rabbit hole of extending <code>ls</code>, I&rsquo;ll leave that as an
exercise to the reader.
Our example does a bit of post processing on the trace output to make it more
readable for our purposes.
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #ECBE7B;">mkdir</span> -p /tmp/naive-nix-filter/foo;
<span style="color: #ECBE7B;">cd</span> /tmp/naive-nix-filter &gt;/dev/null;
<span style="color: #ECBE7B;">touch</span> <span style="color: #51afef;">{</span>,foo/<span style="color: #51afef;">}</span>package<span style="color: #51afef;">{</span>,-lock<span style="color: #51afef;">}</span>.json;
<span style="color: #ECBE7B;">mkdir</span> bar;
<span style="color: #ECBE7B;">touch</span> bar/baz;
<span style="color: #ECBE7B;">cat</span> &lt;&lt;<span style="color: #98be65;">'EOF'</span> &gt; naive.nix
<span style="color: #98be65;">let</span>
<span style="color: #98be65;">  inherit (builtins) attrValues mapAttrs readDir filterSource;</span>
<span style="color: #98be65;">  pkgs = import &lt;nixpkgs&gt; {};</span>
<span style="color: #98be65;">  inherit (pkgs.lib.sources) trace cleanSourceWith;</span>

<span style="color: #98be65;">  naiveFilter = name: type: let bname = baseNameOf name; in</span>
<span style="color: #98be65;">    ( type == "regular" ) &amp;&amp;</span>
<span style="color: #98be65;">    ( ( bname == "package.json" ) || ( bname == "package-lock.json" ) );</span>

<span style="color: #98be65;">  betterFilter = name: type:</span>
<span style="color: #98be65;">    ( type == "directory" ) || ( naiveFilter name type );</span>

<span style="color: #98be65;">in trace ( cleanSourceWith { filter = betterFilter; src = ./.; } )</span>
<span style="color: #98be65;">EOF</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">`trace' prints to `stderr' and we don't care about the result so redirect.</span>
nix eval -f ./naive.nix <span style="color: #da8548; font-weight: bold;">3</span>&gt;&amp;<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">1</span>&gt;/dev/null <span style="color: #da8548; font-weight: bold;">2</span>&gt;&amp;3-       <span style="color: #98be65;">\</span>
  |<span style="color: #ECBE7B;">grep</span> <span style="color: #98be65;">' = true$'</span>|cut -d<span style="color: #98be65;">' '</span> -f3|sed <span style="color: #98be65;">"s,.*</span><span style="color: #a9a1e1;">$</span><span style="color: #dcaeea;">PWD</span><span style="color: #98be65;">,.,"</span>;
<span style="color: #ECBE7B;">cd</span> - &gt;/dev/null;
<span style="color: #ECBE7B;">rm</span> -rf /tmp/naive-nix-filter;
</pre>
</div>

<pre class="example">
./bar
./foo
./foo/package-lock.json
./foo/package.json
./package-lock.json
./package.json
</pre>


<p>
This is looking much better, we preserved out <code>package[-lock].json</code> files
recursively as intended, and we deleted the gargage file <code>bar/baz</code> as well.
The only thing we might want to improve here would be to prune the empty
directory <code>bar/</code>, since deleting <code>bar/baz</code> makes it pretty useless.
I&rsquo;ll note that while this detail seems somewhat pedantic, the existing of
this file would produce a different hash than if it were deleted.
Since our goal was truly &ldquo;preserve only <code>package[-lock].json</code>&rdquo; files, lets
see if we can delete it.
</p>
</div>
</li>

<li><a id="orgc1da777"></a>Diving Off the Deep End<br />
<div class="outline-text-5" id="text-4-3-1-3">
<p>
Let me preface this example by saying, &ldquo;yes this is incredibly extra, and I
don&rsquo;t actually expect anyone to know how to leverage <code>cleanSource</code> internals
in this way in a regular derivation&rdquo;.
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="color: #ECBE7B;">mkdir</span> -p /tmp/naive-nix-filter/foo;
<span style="color: #ECBE7B;">cd</span> /tmp/naive-nix-filter &gt;/dev/null;
<span style="color: #ECBE7B;">touch</span> <span style="color: #51afef;">{</span>,foo/<span style="color: #51afef;">}</span>package<span style="color: #51afef;">{</span>,-lock<span style="color: #51afef;">}</span>.json;
<span style="color: #ECBE7B;">mkdir</span> bar;
<span style="color: #ECBE7B;">touch</span> bar/baz;
<span style="color: #ECBE7B;">cat</span> &lt;&lt;<span style="color: #98be65;">'EOF'</span> &gt; naive.nix
<span style="color: #98be65;">let</span>
<span style="color: #98be65;">  inherit (builtins) attrValues mapAttrs readDir filterSource;</span>
<span style="color: #98be65;">  pkgs = import &lt;nixpkgs&gt; {};</span>
<span style="color: #98be65;">  inherit (pkgs.lib) hasPrefix;</span>
<span style="color: #98be65;">  inherit (pkgs.lib.sources) trace cleanSourceWith;</span>

<span style="color: #98be65;">  naiveFilter = name: type: let bname = baseNameOf name; in</span>
<span style="color: #98be65;">    ( type == "regular" ) &amp;&amp;</span>
<span style="color: #98be65;">    ( ( bname == "package.json" ) || ( bname == "package-lock.json" ) );</span>

<span style="color: #98be65;">  # If your eyes glaze over while reading this, that's totally fine.</span>
<span style="color: #98be65;">  # The overview is apply our original filter to regular files,</span>
<span style="color: #98be65;">  # but for directories perform a dry run of filtering recursively,</span>
<span style="color: #98be65;">  # and remove any directories which would end up being empty</span>
<span style="color: #98be65;">  # after cleaning.</span>
<span style="color: #98be65;">  # This is </span><span style="color: #98be65;">less</span><span style="color: #98be65;"> efficient than a tree walker ( by a lot ), but</span>
<span style="color: #98be65;">  # it's still better than the `gitignoreSourcePure' routine.</span>
<span style="color: #98be65;">  filterSourceRmdir = filt: src:</span>
<span style="color: #98be65;">    let</span>
<span style="color: #98be65;">      pstr = p: if ( p ? origSrc ) then p.origSrc else ( toString p );</span>
<span style="color: #98be65;">      absPath = p:</span>
<span style="color: #98be65;">        let op = pstr p;</span>
<span style="color: #98be65;">        in if ( hasPrefix "/" op ) then op else ( ( pstr src ) + "/${p}" );</span>
<span style="color: #98be65;">      fr = n: t:</span>
<span style="color: #98be65;">        ( filt n t ) ||</span>
<span style="color: #98be65;">        ( ( t == "directory" ) &amp;&amp;</span>
<span style="color: #98be65;">          ( ( readDir ( filterSourceRmdir filt ( absPath n ) ).outPath )</span>
<span style="color: #98be65;">            != {} )</span>
<span style="color: #98be65;">        );</span>
<span style="color: #98be65;">    in cleanSourceWith { filter = fr; inherit src; };</span>

<span style="color: #98be65;">  bestFilter = filterSourceRmdir naiveFilter;</span>

<span style="color: #98be65;">in trace ( bestFilter ./. )</span>
<span style="color: #98be65;">EOF</span>
<span style="color: #5B6268;"># </span><span style="color: #5B6268;">`trace' prints to `stderr' and we don't care about the result so redirect.</span>
nix eval -f ./naive.nix <span style="color: #da8548; font-weight: bold;">3</span>&gt;&amp;<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">1</span>&gt;/dev/null <span style="color: #da8548; font-weight: bold;">2</span>&gt;&amp;3-       <span style="color: #98be65;">\</span>
  |<span style="color: #ECBE7B;">grep</span> <span style="color: #98be65;">' = true$'</span>|cut -d<span style="color: #98be65;">' '</span> -f3|sed <span style="color: #98be65;">"s,.*</span><span style="color: #a9a1e1;">$</span><span style="color: #dcaeea;">PWD</span><span style="color: #98be65;">,.,"</span>;
<span style="color: #ECBE7B;">cd</span> - &gt;/dev/null;
<span style="color: #ECBE7B;">rm</span> -rf /tmp/naive-nix-filter;
</pre>
</div>

<pre class="example">
./foo
./foo/package-lock.json
./foo/package.json
./package-lock.json
./package.json
</pre>


<p>
VICTORY!
</p>

<p>
&#x2026; Well alright I&rsquo;ll admit, while we got the expected output, we&rsquo;ve created an
abomination - the likes of which was probably not worth the effort and is still
incredibly wasteful because nested directories at depth <code>N</code> are redundantly
processed <code>N - 1</code> times.
</p>

<p>
A far better implementation is a simple tree walker that collects matching files,
but this was nonetheless a good way to explore some advanced filtering.
</p>
</div>
</li>

<li><a id="orgd9f0c63"></a>Recommended Solution<br />
<div class="outline-text-5" id="text-4-3-1-4">
<p>
A low effort, but highly effective approach that I actually suggest using in the
field is to use <code>betterFilter</code>, then use <code>stdenvNoCC.mkDerivation</code> with <code>find</code>
and <code>rmdir</code>.
</p>

<p>
In this example I&rsquo;ll do our workspace setup as a derivation, and simply use <code>readDir</code>
to confirm that the directory <code>bar</code> is deleted.
We could just as well use the same pattern from the previous examples where we create
the workspace in <code>sh</code>; I&rsquo;m just using this as an opportunity to sneak in an example
using <code>runCommandNoCC</code>.
</p>

<p>
This means we will use an intermediate builder rather than producing a single derivation,
so we take a small hit on space in the Nix store, and for spinning up a builder
( <code>stdenvNoCC.mkDerivation</code> has a relatively small footprint ); but we would
have saved ~1 1/2 hours of reading, and would still get the hash we care about
for our &ldquo;real build&rdquo; - which is what we actually care about.
</p>

<div class="org-src-container">
<pre class="src src-nix">  <span style="color: #51afef;">let</span>
    <span style="color: #51afef;">inherit</span> (<span style="color: #c678dd;">builtins</span>) attrValues mapAttrs readDir filterSource;
    <span style="color: #dcaeea;">pkgs</span> = <span style="color: #c678dd;">import</span> <span style="color: #a9a1e1;">&lt;nixpkgs&gt;</span> {};
    <span style="color: #51afef;">inherit</span> (pkgs) stdenvNoCC runCommandNoCC;
    <span style="color: #51afef;">inherit</span> (pkgs.lib.sources) trace cleanSourceWith;

    <span style="color: #dcaeea;">example-src</span> = runCommandNoCC <span style="color: #98be65;">"source"</span> {} <span style="color: #98be65;">''</span>
<span style="color: #98be65;">      mkdir -p $out/foo $out/bar;</span>
<span style="color: #98be65;">      touch $out/{,foo/}package{,-lock}.json $out/bar/baz;</span>
<span style="color: #98be65;">    ''</span>;

    <span style="color: #dcaeea;">naiveFilter</span> = name: type: <span style="color: #51afef;">let</span> <span style="color: #dcaeea;">bname</span> = <span style="color: #c678dd;">baseNameOf</span> name; <span style="color: #51afef;">in</span>
      ( type == <span style="color: #98be65;">"regular"</span> ) &amp;&amp;
      ( ( bname == <span style="color: #98be65;">"package.json"</span> ) || ( bname == <span style="color: #98be65;">"package-lock.json"</span> ) );

    <span style="color: #dcaeea;">betterFilter</span> = name: type:
      ( type == <span style="color: #98be65;">"directory"</span> ) || ( naiveFilter name type );

    <span style="color: #dcaeea;">mostlyClean</span> = cleanSourceWith { <span style="color: #dcaeea;">filter</span> = betterFilter; <span style="color: #dcaeea;">src</span> = example-src; };

    <span style="color: #dcaeea;">fullyClean</span> = stdenvNoCC.mkDerivation {
      <span style="color: #51afef;">inherit</span> (mostlyClean) name;
      <span style="color: #dcaeea;">src</span> = mostlyClean;
      <span style="color: #dcaeea;">phases</span> = [<span style="color: #98be65;">"unpackPhase"</span> <span style="color: #98be65;">"buildPhase"</span> <span style="color: #98be65;">"installPhase"</span>];
      <span style="color: #dcaeea;">buildPhase</span> = <span style="color: #98be65;">"find . -type d -empty -exec rmdir {} \+"</span>;
      <span style="color: #dcaeea;">installPhase</span> = <span style="color: #98be65;">"cp -pr --reflink=auto -- . $out"</span>;
      <span style="color: #5B6268;"># This is such a quick operation that queing a remote builder isn't worth</span>
      <span style="color: #5B6268;"># the effort; `preferLocalBuild' will cause this to be run locally.</span>
      <span style="color: #dcaeea;">preferLocalBuild</span> = <span style="color: #c678dd;">true</span>;
    };
  <span style="color: #51afef;">in</span> readDir fullyClean.outPath
</pre>
</div>

<pre class="example">
{ foo = "directory"; "package-lock.json" = "regular"; "package.json" = "regular"; }
</pre>


<p>
In practice, we really don&rsquo;t mind producing a large number of small derivations as
long as we have valid reasons to do so; unlike docker containers a builder runs
on very low overhead, for a trivial routine like this we really just make a
temporary directory, add some junk to <code>PATH</code>, copy our inputs, and delete the
temporary directory after without any virtualization or other non-sense.
</p>

<p>
In this case our &ldquo;inputs&rdquo; are just a few text files, so this intermediate isn&rsquo;t
expensive to spin up - you wouldn&rsquo;t want to do this on a large unfiltered mono-repo!
</p>

<p>
Using technically unnecessary intermediate derivations is a common practice when
working on projects which are under active development, and may fail - adding
intermediate derivations with well defined inputs allows us to effectively
create cacheable &ldquo;check-points&rdquo; that we can revert to in the event of a failure.
</p>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org8557f4c" class="outline-2">
<h2 id="org8557f4c"><span class="section-number-2">5.</span> Bread and Butter Functions</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgfc54a45" class="outline-3">
<h3 id="orgfc54a45"><span class="section-number-3">5.1.</span> <code>listToAttrs</code>, <code>attrNames</code>, and <code>attrValues</code></h3>
<div class="outline-text-3" id="text-5-1">
<p>
These bad boys help you convert between lists and attrsets, making them some of the most commonly used functions in Nix.
Upfront I&rsquo;ll give a few examples of when you might need to use these functions ( aside from the basic behaviors ):
</p>
<ul class="org-ul">
<li>Rename keys in an attrset, or &ldquo;rekey&rdquo;.</li>
<li>Sort members of an attrset.</li>
<li>Filter out members of an attrset.</li>
<li>Deduplicate a list from a particular value or subset of values. ( destructive form of &ldquo;group-by&rdquo; )</li>
</ul>
</div>

<div id="outline-container-orgf891550" class="outline-4">
<h4 id="orgf891550"><span class="section-number-4">5.1.1.</span> The Basics</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
The function names themselves largely explain what each function does; but
I&rsquo;ll show a few example calls just for kicks:
</p>
<div class="org-src-container">
<pre class="src src-nix">  builtins.attrNames { <span style="color: #dcaeea;">foo</span> = <span style="color: #da8548; font-weight: bold;">1</span>; <span style="color: #dcaeea;">bar</span> = <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #dcaeea;">baz</span> = { <span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">3</span>; <span style="color: #dcaeea;">y</span> = <span style="color: #da8548; font-weight: bold;">4</span>; }; }
  <span style="color: #5B6268;"># =&gt; [ "foo" "bar" "baz" ]</span>

  builtins.attrValues { <span style="color: #dcaeea;">foo</span> = <span style="color: #da8548; font-weight: bold;">1</span>; <span style="color: #dcaeea;">bar</span> = <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #dcaeea;">baz</span> = { <span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">3</span>; <span style="color: #dcaeea;">y</span> = <span style="color: #da8548; font-weight: bold;">4</span>; }; }
  <span style="color: #5B6268;"># =&gt; [ 1 2 { x = 3; y = 4; } ]</span>

  builtins.listToAttrs [{ <span style="color: #dcaeea;">name</span> = <span style="color: #98be65;">"foo"</span>; <span style="color: #dcaeea;">value</span> = <span style="color: #da8548; font-weight: bold;">1</span>; } { <span style="color: #dcaeea;">name</span> = <span style="color: #98be65;">"bar"</span>; <span style="color: #dcaeea;">value</span> = <span style="color: #da8548; font-weight: bold;">2</span>; } { <span style="color: #dcaeea;">name</span> = <span style="color: #98be65;">"baz"</span>; <span style="color: #dcaeea;">value</span> = { <span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">3</span>; <span style="color: #dcaeea;">y</span> = <span style="color: #da8548; font-weight: bold;">4</span>; } }]
  <span style="color: #5B6268;"># =&gt; { foo = 1; bar = 2; baz = { x = 3; y = 4; }; }</span>
</pre>
</div>

<p>
You can see additional documentation on each function in the Nix manual; or in the Nix repl by running:
</p>
<div class="org-src-container">
<pre class="src src-nix">  nix-repl&gt; :doc builtins.listToAttrs
</pre>
</div>
</div>
</div>

<div id="outline-container-org508073d" class="outline-4">
<h4 id="org508073d"><span class="section-number-4">5.1.2.</span> Some Simple Utilities</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
Given the basic functions above, we&rsquo;ll make a few helper functions that
you&rsquo;ll see throughout a lot of Nix source code as standard design patterns.
</p>

<p>
In the field these aren&rsquo;t usually defined as real functions, and are
written &ldquo;inline&rdquo;, but others are available as members of <code>nixpkgs.lib</code> and
are commonly referred to as <code>lib</code> members.
</p>
</div>

<ol class="org-ol">
<li><a id="org61f0241"></a><code>attrsToList</code><br />
<div class="outline-text-5" id="text-5-1-2-1">
<p>
This is the opposite of <code>builtins.listToAttrs</code>.
Given an attrset, produce a list of <code>{ name = ...; value = ...; }</code> pairs.
Calling <code>x: ( builtins.listToAttrs ( attrsToList x ) ) == x</code> is a good unit test for this function.
</p>
</div>

<ol class="org-ol">
<li><a id="orgd37e36f"></a>Problem Template<br />
<div class="outline-text-6" id="text-5-1-2-1-1">
<div class="org-src-container">
<pre class="src src-nix">  <span style="color: #51afef;">let</span>
    <span style="color: #5B6268;"># Let define a simple test function.</span>
    <span style="color: #dcaeea;">check</span> = x: ( builtins.listToAttrs ( attrsToList x ) ) == x;
    <span style="color: #5B6268;"># And a basic set of test data.</span>
    <span style="color: #dcaeea;">data</span> = { <span style="color: #dcaeea;">foo</span> = <span style="color: #da8548; font-weight: bold;">1</span>; <span style="color: #dcaeea;">bar</span> = <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #dcaeea;">baz</span> = { <span style="color: #dcaeea;">x</span> = <span style="color: #da8548; font-weight: bold;">3</span>; <span style="color: #dcaeea;">y</span> = <span style="color: #da8548; font-weight: bold;">4</span>; }; };

    <span style="color: #5B6268;"># Lets implement the actual function.</span>
    <span style="color: #dcaeea;">attrsToList</span> = x:
      <span style="color: #5B6268;">/* </span><span style="color: #ff6c6b; font-weight: bold;">FIXME</span><span style="color: #5B6268;"> */</span> <span style="color: #ECBE7B;">throw</span> <span style="color: #98be65;">"Delete this line, and implement your solution here."</span>;

  <span style="color: #51afef;">in</span> <span style="color: #ECBE7B;">assert</span> check data;  <span style="color: #5B6268;"># Make our test case an assertion.</span>
     attrsToList data
  <span style="color: #5B6268;"># ==&gt; [ { name = "bar"; value = 2; } { name = "baz"; value = { x = 3; y = 4; }; } { name = "foo"; value = 1; } ]</span>
</pre>
</div>
</div>
</li>
</ol>
</li>

<li><a id="orgc68ca72"></a><code>filterAttrs</code><br />
<div class="outline-text-5" id="text-5-1-2-2">
<p>
Given a predicate which takes &ldquo;name&rdquo; ( key ) and &ldquo;value&rdquo; as arguments, filter
out attributes from an attrset.
</p>
</div>

<ol class="org-ol">
<li><a id="orgd6e6775"></a>Problem Template<br />
<div class="outline-text-6" id="text-5-1-2-2-1">
<div class="org-src-container">
<pre class="src src-nix">  <span style="color: #51afef;">let</span>

    <span style="color: #5B6268;"># A test attrset.</span>
    <span style="color: #dcaeea;">data</span> = { <span style="color: #dcaeea;">foo</span> = <span style="color: #da8548; font-weight: bold;">1</span>; <span style="color: #dcaeea;">bar</span> = <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #dcaeea;">baz</span> = <span style="color: #da8548; font-weight: bold;">3</span>; <span style="color: #dcaeea;">quux</span> = <span style="color: #da8548; font-weight: bold;">4</span>; };
    <span style="color: #5B6268;"># An test predicate.</span>
    <span style="color: #dcaeea;">isValueEven</span> = name: value:
      ( value / <span style="color: #da8548; font-weight: bold;">2</span> ) != ( ( value - <span style="color: #da8548; font-weight: bold;">1</span> ) / <span style="color: #da8548; font-weight: bold;">2</span> );


    <span style="color: #dcaeea;">filterAttrs</span> = pred: attrs:
      <span style="color: #5B6268;">/* </span><span style="color: #ff6c6b; font-weight: bold;">FIXME</span><span style="color: #5B6268;"> */</span> <span style="color: #ECBE7B;">throw</span> <span style="color: #98be65;">"Delete this line, and implement your solution here."</span>;

    <span style="color: #dcaeea;">check</span> = d:
      ( filterAttrs isValueEven d ) == { <span style="color: #dcaeea;">bar</span> = <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #dcaeea;">quux</span> = <span style="color: #da8548; font-weight: bold;">4</span>; };

  <span style="color: #51afef;">in</span> <span style="color: #ECBE7B;">assert</span> check data;  <span style="color: #5B6268;"># Make our test case an assertion.</span>
     filterAttrs data
  <span style="color: #5B6268;"># ==&gt; { bar = 2; quux = 4; }</span>
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>
</div>

<div id="outline-container-org9b83774" class="outline-3">
<h3 id="org9b83774"><span class="section-number-3">5.2.</span> <code>fromJSON</code>, <code>toJSON</code>, <code>readFile</code>, <code>toFile</code>, and <code>fetchurl</code></h3>
<div class="outline-text-3" id="text-5-2">
<p>
Used for IO and Nix value conversion.
</p>
</div>

<div id="outline-container-org05b6407" class="outline-4">
<h4 id="org05b6407"><span class="section-number-4">5.2.1.</span> The Basics</h4>
<div class="outline-text-4" id="text-5-2-1">
<div class="org-src-container">
<pre class="src src-nix">  builtins.toFile <span style="color: #98be65;">"greeting.txt"</span> <span style="color: #98be65;">"Howdy!\n"</span>
  <span style="color: #5B6268;"># =&gt; "/nix/store/861dpyjnjslzbzvd8xv6xjhfrw9hc96c-greeting.txt"</span>

  <span style="color: #5B6268;"># Assuming we have a `foo.txt' in current working directory.</span>
  builtins.readFile <span style="color: #a9a1e1;">./foo.txt</span>
  <span style="color: #5B6268;"># =&gt; "hey\nthere\ndude\n"</span>

  builtins.toJSON { <span style="color: #dcaeea;">foo</span> = <span style="color: #da8548; font-weight: bold;">1</span>; <span style="color: #dcaeea;">bar</span> = <span style="color: #da8548; font-weight: bold;">2</span>; <span style="color: #dcaeea;">baz.x</span> = <span style="color: #da8548; font-weight: bold;">3</span>; <span style="color: #dcaeea;">baz.y</span> = <span style="color: #da8548; font-weight: bold;">4</span>; }
  <span style="color: #5B6268;"># =&gt; "{ \"foo\": 1, \"bar\": 2, \"baz\": { \"x\": 3, \"y\": 4 } }"</span>

  builtins.fromJSON <span style="color: #98be65;">''{ "foo": 1, "bar": 2, "baz": { "x": 3, "y": 4 } }''</span>
  <span style="color: #5B6268;"># =&gt; { foo = 1; bar = 2; baz = { x = 3; y = 4; }; }</span>

  builtins.fetchurl <span style="color: #98be65;">"https://registry.npmjs.org/lodash"</span>
  <span style="color: #5B6268;"># =&gt; "/nix/store/xsc3i1na4lhj556y9qxb55nki04nhmiw-lodash"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org652ade8" class="outline-4">
<h4 id="org652ade8"><span class="section-number-4">5.2.2.</span> Some Simple Utilities</h4>
<div class="outline-text-4" id="text-5-2-2">
<p>
Some common helpers.
</p>
</div>

<ol class="org-ol">
<li><a id="org02f087e"></a><code>importJSON</code><br />
<div class="outline-text-5" id="text-5-2-2-1">
<p>
Given a filename, read and convert from JSON to a Nix attrset.
</p>
</div>

<ol class="org-ol">
<li><a id="org3adffb8"></a>Problem Template<br />
<div class="outline-text-6" id="text-5-2-2-1-1">
<div class="org-src-container">
<pre class="src src-nix">  <span style="color: #51afef;">let</span>

    <span style="color: #5B6268;"># Create a test file to run with.</span>
    <span style="color: #dcaeea;">file</span> = builtins.toFile <span style="color: #98be65;">"foo.json"</span> <span style="color: #98be65;">''{ "foo": 1, "bar": { "baz": "quux" } }''</span>;

    <span style="color: #dcaeea;">importJSON</span> = f:
      <span style="color: #5B6268;">/* </span><span style="color: #ff6c6b; font-weight: bold;">FIXME</span><span style="color: #5B6268;"> */</span> <span style="color: #ECBE7B;">throw</span> <span style="color: #98be65;">"Delete this line, and implement your solution here."</span>;

    <span style="color: #dcaeea;">check</span> = f:
      ( importJSON f ) == { <span style="color: #dcaeea;">foo</span> = <span style="color: #da8548; font-weight: bold;">1</span>; <span style="color: #dcaeea;">bar.baz</span> = <span style="color: #98be65;">"quux"</span>; };

  <span style="color: #51afef;">in</span> <span style="color: #ECBE7B;">assert</span> check file;  <span style="color: #5B6268;"># Make our test case an assertion.</span>
     importJSON file
  <span style="color: #5B6268;"># ==&gt; { bar = { baz = "quux"; }; foo = 1; }</span>
</pre>
</div>
</div>
</li>
</ol>
</li>

<li><a id="orgf6809c1"></a><code>fetchJSON</code><br />
<div class="outline-text-5" id="text-5-2-2-2">
<p>
Given a url, fetch, read and convert from JSON to a Nix attrset.
</p>
</div>

<ol class="org-ol">
<li><a id="org6e96edd"></a>Problem Template<br />
<div class="outline-text-6" id="text-5-2-2-2-1">
<div class="org-src-container">
<pre class="src src-nix">  <span style="color: #51afef;">let</span>

    <span style="color: #5B6268;"># Create a test url to run with.</span>
    <span style="color: #dcaeea;">url</span> = <span style="color: #98be65;">"https://registry.npmjs.org/lodash"</span>;

    <span style="color: #dcaeea;">fetchJSON</span> = u:
      <span style="color: #5B6268;">/* </span><span style="color: #ff6c6b; font-weight: bold;">FIXME</span><span style="color: #5B6268;"> */</span> <span style="color: #ECBE7B;">throw</span> <span style="color: #98be65;">"Delete this line, and implement your solution here."</span>;

    <span style="color: #dcaeea;">check</span> = u:
      ( fetchJSON u )._id == <span style="color: #98be65;">"lodash"</span>;

  <span style="color: #51afef;">in</span> <span style="color: #ECBE7B;">assert</span> check url;  <span style="color: #5B6268;"># Make our test case an assertion.</span>
     <span style="color: #5B6268;"># Omit a few fields from our output</span>
     <span style="color: #c678dd;">removeAttrs</span> ( fetchJSON url ) [
       <span style="color: #98be65;">"versions"</span>
       <span style="color: #98be65;">"readme"</span>
       <span style="color: #98be65;">"time"</span>
       <span style="color: #98be65;">"maintainers"</span>
       <span style="color: #98be65;">"contributors"</span>
       <span style="color: #98be65;">"users"</span>
     ]
  <span style="color: #5B6268;"># ==&gt; { _id = "lodash"; ... }</span>
</pre>
</div>
</div>
</li>
</ol>
</li>
</ol>
</div>

<div id="outline-container-orgde6460b" class="outline-4">
<h4 id="orgde6460b"><span class="section-number-4">5.2.3.</span> Related Functions</h4>
<div class="outline-text-4" id="text-5-2-3">
<ul class="org-ul">
<li><code>builtins.toXML</code>
<ul class="org-ul">
<li>Useful to feed language servers and static analyzers.</li>
</ul></li>
<li><code>builtins.fromTOML</code>
<ul class="org-ul">
<li>Basically INI</li>
</ul></li>
<li><code>nixpkgs.lib.generators.toDhall</code>
<ul class="org-ul">
<li>For Haskellers.</li>
</ul></li>
<li><code>nixpkgs.lib.toINI</code>
<ul class="org-ul">
<li>Git: <code>nixpkgs.lib.generators.toGitINI</code></li>
<li>Hierarchical INI: <code>nixpkgs.lib.generators.toINIWithGlobalSection</code></li>
</ul></li>
<li><code>nixpkgs.lib.generators.toPlist</code>
<ul class="org-ul">
<li>Great for generating OSX Services.</li>
</ul></li>
<li><code>nixpkgs.lib.generators.toPretty</code>
<ul class="org-ul">
<li>Generic &ldquo;Nix to String&rdquo; routines.</li>
<li>Similar to the Nix REPL&rsquo;s <code>:p</code> feature, but more robust.</li>
<li>Allows values to carry specialized <code>__toPretty</code> functors.</li>
</ul></li>
<li><code>nixpkgs.lib.generators.toYAML</code>
<ul class="org-ul">
<li>Personally I prefer <code>builtins.toJSON</code>, but still useful.</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Alex Ameen</p>
<p class="date">Created: 2022-10-20 Thu 11:54</p>
</div>
</body>
</html>
